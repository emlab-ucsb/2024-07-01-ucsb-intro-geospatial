---
title: Explore and Plot by Vector Layer Attributes
teaching: 40
exercises: 20
source: Rmd
---

```{r setup, echo=FALSE}
source("setup.R")
```

::::::::::::::::::::::::::::::::::::::: objectives

- Query attributes of a spatial object.
- Subset spatial objects using specific attribute values.
- Plot a vector feature, colored by unique attribute values.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- How can I compute on the attributes of a spatial object?

::::::::::::::::::::::::::::::::::::::::::::::::::

This episode continues our discussion of vector layer attributes and covers how
to work with vector layer attributes in R. It covers how to identify and query
layer attributes, as well as how to subset features by specific attribute
values. Finally, we will learn how to plot a feature according to a set of
attribute values.

## Load the Data

We will continue using the `sf` and `ggplot2` packages in this
episode. Make sure that you have these packages loaded. We will continue to
work with the three ESRI `shapefiles` (vector layers) that we loaded in a
previous episode.

```{r load-libraries, message=FALSE, results="hide"}
library(ggplot2)
library(dplyr)
library(sf)
```

```{r load-data, results="hide"}
point_HARV <-
    st_read("data/NEON-DS-Site-Layout-Files/HARV/HARVtower_UTM18N.shp")
lines_HARV <- st_read("data/NEON-DS-Site-Layout-Files/HARV/HARV_roads.shp")
aoi_boundary_HARV <-
    st_read("data/NEON-DS-Site-Layout-Files/HARV/HarClip_UTMZ18.shp")
```

## Query Vector Feature Metadata

As we discussed in the
[Open and Plot Vector Layers in R](12-vector-open-shapefile-in-r/)
episode, we can view metadata associated with an R object using:

- `st_geometry_type()` - The type of vector data stored in the object.
- `st_bbox()` - The spatial extent (geographic area covered by)
  of the object.
- `st_crs()` - The CRS (spatial projection) of the data.

We started to explore our `point_HARV` object in the previous episode. To see a
summary of all of the metadata associated with our object, we can
view the object with `View(point_HARV)` or print a summary of the object itself
to the console. We're going to do this, but with `lines_HARV` today:

```{r view-object}
lines_HARV
```

We can use the `ncol` function to count the number of attributes associated
with a spatial object too. Note that the geometry is just another column and
counts towards the total.

```{r shapefile-attributes}
ncol(lines_HARV)
```

We can view the individual name of each attribute using the `names()` function
in R:

```{r view-shapefile-attributes}
names(lines_HARV)
```

We could also view just the first 6 rows of attribute values using the `head()`
function to get a preview of the data:

```{r view-shapefile-attributes-head}
head(lines_HARV)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge 1: Attributes for Different Spatial Classes

Explore the attributes associated with the `point_HARV` and `aoi_boundary_HARV`
spatial objects.

1. How many attributes does each have?

2. Who owns the site in the `point_HARV` data object?

3. Which of the following is NOT an attribute of the `point_HARV` data object?

  A) Latitude      B) County     C) Country

:::::::::::::::  solution

## Solution

1) To find the number of attributes, we use the `ncol()` function:

```{r}
ncol(point_HARV)
ncol(aoi_boundary_HARV)
```

2) Ownership information is in a column named `Ownership`:

```{r}
point_HARV$Ownership
```

3) To see a list of all of the attributes, we can use the `names()` function:

```{r}
names(point_HARV)
```

"Country" is not an attribute of this object.



:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Explore Values within One Attribute

We can explore individual values stored within a particular attribute.
Comparing attributes to a spreadsheet or a data frame, this is similar to
exploring values in a column. We did this with the `gapminder` dataframe in
an earlier lesson.
For spatial objects, we can use the same syntax: `objectName$attributeName`.

We can see the contents of the `TYPE` field of our lines feature:

```{r explore-attribute-values}
lines_HARV$TYPE
```

To see only unique values within the `TYPE` field, we can use the `unique()`
function for extracting the possible values of a character variable.

```{r explor-attribute-values-factor}
unique(lines_HARV$TYPE)
```

### Subset Features

We can use the `filter()` function from `dplyr` to select a subset of features from a spatial object in R, just like with data
frames.

For example, we might be interested only in features that are of `TYPE`
"footpath". Once we subset out this data, we can use it as input to other code
so that code only operates on the footpath lines.

```{r Subsetting-shapefiles}
footpath_HARV <- lines_HARV %>%
  filter(TYPE == "footpath")
nrow(footpath_HARV)
```

Our subsetting operation reduces the `features` count to 2. This means that
only two feature lines in our spatial object have the attribute
`TYPE == footpath`. We can plot only the footpath lines:

```{r plot-subset-shapefile, fig.cap="Map of the footpaths in the study area."}
ggplot() +
  geom_sf(data = footpath_HARV) +
  labs(title = "NEON Harvard Forest Field Site", 
       subtitle = "Footpaths") +
  coord_sf()
```

There are two features in our footpaths subset. Why does the plot look like
there is only one feature? Let's adjust the colors used in our plot. If we have
2 features in our vector object, we can plot each using a unique color by
assigning a column name to the color aesthetic (`color =`). We use the syntax
`mapping = aes(color = )` to do this. We'll use the `OBJECTID` column for the 
color aesthetic in this example, but because it is a number, we will have to
convert it to a categorical value (a factor) first. 
We can also alter the default line thickness by
using the `linewidth =` parameter, as the default value can be hard to see.
Note that `linewidth` is placed outside of the `aes()` function, as we are not
connecting line thickness to a data variable.

```{r plot-subset-shapefile-unique-colors, fig.cap="Map of the footpaths in the study area where each feature is colored differently."}
ggplot() +
  geom_sf(data = footpath_HARV, 
          mapping = aes(color = factor(OBJECTID)), linewidth = 1.5) +
  labs(color = "Footpath ID", 
       title = "NEON Harvard Forest Field Site", 
       subtitle = "Footpaths") +
  coord_sf()
```

Now, we see that there are in fact two features in our plot!

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge 2: Subset Spatial Line Objects Part 1

Subset out all `boardwalk` from the lines layer and plot it.

:::::::::::::::  solution

## Solution

First we will save an object with only the boardwalk lines:

```{r}
boardwalk_HARV <- lines_HARV %>%
  filter(TYPE == "boardwalk")
```

Let's check how many features there are in this subset:

```{r}
nrow(boardwalk_HARV)
```

Now let's plot that data:

```{r harv-boardwalk-map, fig.cap="Map of the boardwalks in the study area."}
ggplot() +
  geom_sf(data = boardwalk_HARV, linewidth = 1.5) +
  labs(title = "NEON Harvard Forest Field Site", 
       subtitle = "Boardwalks") +
  coord_sf()
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge 3: Subset Spatial Line Objects Part 2

Subset out all `stone wall` features from the lines layer and plot it. For each
plot, color each feature using a unique color.

:::::::::::::::  solution

## Solution

First we will save an object with only the stone wall lines and check the
number of features:

```{r}
stoneWall_HARV <- lines_HARV %>%
  filter(TYPE == "stone wall")
nrow(stoneWall_HARV)
```

Now we can plot the data:

```{r harv-stone-wall-map, fig.cap="Map of the stone walls in the study area where each feature is colored differently."}
ggplot() +
  geom_sf(data = stoneWall_HARV, 
          mapping = aes(color = factor(OBJECTID)), linewidth = 1.5) +
  labs(color = "Wall ID", 
       title = "NEON Harvard Forest Field Site",
       subtitle = "Stonewalls") +
  coord_sf()
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Customize Plots

In the examples above, `ggplot()` automatically selected colors for each line
based on a default color order. If we don't like those default colors, we can
create a vector of colors - one for each feature.

First we will check how many unique line types there are:

```{r palette-and-plot}
unique(lines_HARV$TYPE)
```

Then we can create a palette of four colors, one for each
feature in our vector object.

```{r}
road_colors <- c("blue", "green", "navy", "purple")
```

We can tell `ggplot` to use these colors when we plot the data.

```{r harv-paths-map, fig.cap="Roads and trails in the area."}
ggplot() +
  geom_sf(data = lines_HARV, mapping = aes(color = TYPE)) +
  scale_color_manual(values = road_colors) +
  labs(color = "Road Type", 
       title = "NEON Harvard Forest Field Site", 
       subtitle = "Roads & Trails") +
  coord_sf()
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Data Tip

Note that `ggplot` automatically decides which colors belong with which variables, based
on the order of the colors in the color vector, and the alphabetical order of the 
road types. You can specify which colors to use for which road type by creating
a named vector: 

```{r, eval = FALSE, echo = TRUE}
road_colors <- c("stone wall" = "blue", "board walk" = "green",
                 "footpath" = "navy", "woods road" = "purple")
```


::::::::::::::::::::::::::::::::::::::::::::::::::


### Adjust Line Width

We adjusted line width universally earlier. If we want a unique line width for
each level or attribute category in our spatial object, we can use the
same syntax that we used for colors, above.

We already know that we have four different `TYPE`s in the lines\_HARV object,
so we will set four different line widths.

```{r line-width-unique}
line_widths <- c(1, 2, 3, 4)
```

We can use those line widths when we plot the data.

```{r harv-paths-map-wide, fig.cap="Roads and trails in the area demonstrating how to use different line thickness and colors."}
ggplot() +
  geom_sf(data = lines_HARV, 
          mapping = aes(color = TYPE, linewidth = TYPE)) +
  scale_color_manual(values = road_colors) +
  scale_linewidth_manual(values = line_widths) +
  labs(color = "Road Type",
       linewidth = "Road Type",
       title = "NEON Harvard Forest Field Site",
       subtitle = "Roads & Trails - Line width varies") +
  coord_sf()
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge 4: Plot Line Width by Attribute

In the example above, we set the line widths to be 1, 2, 3, and 4. Because R
orders alphabetically by default, this gave us a plot where woods roads (the
last type) were the thickest and boardwalks were the thinnest.

Let's create another plot where we show the different line types with the
following thicknesses:

1. woods road width = 6
2. boardwalks width = 1
3. footpath width = 3
4. stone wall width = 2

:::::::::::::::  solution

## Solution

First we need to look at the levels of our factor to see
what order the road types are in:

```{r}
unique(lines_HARV$TYPE)
```

We then can create our `line_width` vector setting each of the
levels to the desired thickness.

```{r}
line_width <- c("woods road" = 6, "footpath" = 3, 
                "stone wall" = 2, "boardwalk" = 1)
```

Now we can create our plot.

```{r harv-path-line-types, fig.cap="Roads and trails in the area with different line thickness for each type of paths."}
ggplot() +
  geom_sf(data = lines_HARV, mapping = aes(linewidth = TYPE)) +
  scale_linewidth_manual(values = line_width) +
  labs(title = "NEON Harvard Forest Field Site",
       subtitle = "Roads & Trails - Line width varies") +
  coord_sf()
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### Add Plot Legend

When we plot a vector object and specify colors, line widths, etc. using the 
`mapping = aes()` function, R will automatically add a plot to our legend. 
By default, the plot legend will show up on the right side of the plot and 
will include the values that we supplied to the ggplot object. We can adjust
the way our legends look in a variety of ways. 

- We specify the location of our legend by using a default
  keyword. For example, we could use `bottomright`, `top`, `topright`, etc. 
- We can change the font size
- We can change the little things, like the color of the legend box outline
- And so much more! 

Pretty much anything you would want to change on a plot, you can! We do this
using the `theme()` function in R. 

Let's start with our basic plot. We will use the `road_colors` object
that we created above to color the legend. We'll also move the legend 
to the bottom by specifying `theme(legend.position = "bottom")`.

```{r add-legend-to-plot, fig.cap="Roads and trails in the study area using thicker lines than the previous figure."}
ggplot() +
  geom_sf(data = lines_HARV, 
          mapping = aes(color = TYPE), linewidth = 1.5) +
  scale_color_manual(values = road_colors) +
  labs(color = "Road Type", 
       title = "NEON Harvard Forest Field Site",
       subtitle = "Roads & Trails - Default Legend") +
  coord_sf() + 
  theme(legend.position = "bottom")
```

Now, let's change the appearance of our legend by manually setting different
parameters using the `theme()` function. 

We can start by changing the font size in the legend. The way we would do this is 
by adding the following line to our plot code: 
`theme(legend.text = element_text(size = 20))`

This may seem a little confusing, but there is a method to the madness. First, 
we note what we're trying to change (the `legend.text` argument). Next, we have
to specify what kind of object it needs to be. Since we're altering the legend
*text*, it needs to be a text element, so we use the `element_text()` function. Within 
this function, we can specify what we want to change from the default. In this
case, it's the size of the font (`size = 20`), but we could do this for things
like color, the face (plain, italic, bold, bold.italic), the angle of rotation
for the text, etc. 


```{r modify-legend-plot, fig.cap="Map of the paths in the study area with large-font."}
ggplot() +
  geom_sf(data = lines_HARV, 
          mapping = aes(color = TYPE), linewidth = 1.5) +
  scale_color_manual(values = road_colors) +
  labs(color = "Road Type", 
       title = "NEON Harvard Forest Field Site",
       subtitle = "Roads & Trails - Default Legend") +
  coord_sf() + 
  theme(legend.position = "bottom", 
        legend.text = element_text(size = 20)) 
```

We can decide to have a box around the legend, by altering the `legend.box.background` 
to have a black border. Since the legend is a rectangle of sorts, we will use the element: `element_rect()` to adjust these parameters. 

So our new line would be: 

`theme(legend.box.background = element_rect(color = "black"))`


```{r modify-legend-plot-box, fig.cap="Map of the paths in the study area with large-font and an outline around the legend."}

ggplot() +
  geom_sf(data = lines_HARV, 
          mapping = aes(color = TYPE), linewidth = 1.5) +
  scale_color_manual(values = road_colors) +
  labs(color = "Road Type", 
       title = "NEON Harvard Forest Field Site",
       subtitle = "Roads & Trails - Default Legend") +
  coord_sf() + 
  theme(legend.position = "bottom", 
        legend.text = element_text(size = 20), 
        legend.box.background = element_rect(color = "black")) 
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Data Tip

You can modify the default R color palette using the palette method. For
example `palette(rainbow(6))` or `palette(terrain.colors(6))`. You can reset
the palette colors using `palette("default")`!

You can also use colorblind-friendly palettes such as those in the
[viridis package](https://cran.r-project.org/package=viridis).


::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge 5: Plot Lines by Attribute

Create a plot that emphasizes only roads where bicycles and horses are allowed.
To emphasize this, make the lines where bicycles are not allowed THINNER than
the roads where bicycles are allowed.
NOTE: this attribute information is located in the `lines_HARV$BicyclesHo`
attribute.

Be sure to add a title and legend to your map. You might consider a color
palette that has all bike/horse-friendly roads displayed in a bright color. All
other lines can be black.

:::::::::::::::  solution

## Solution

First we explore the `BicyclesHo` attribute to learn the values that correspond
to the roads we need.

```{r}
lines_HARV %>%
  pull(BicyclesHo) %>%
  unique()
```

Now, we can create a data frame with only those roads where bicycles and horses 
are allowed.

```{r}
lines_showHarv <-
  lines_HARV %>%
  filter(BicyclesHo == "Bicycles and Horses Allowed")
```

Finally, we plot the needed roads after setting them to magenta and a thicker 
line width.

```{r harv-paths-bike-horses, fig.cap="Roads and trails in the area highlighting paths where horses and bikes are allowed."}
ggplot() +
  geom_sf(data = lines_HARV) +
  geom_sf(data = lines_showHarv, 
          mapping = aes(color = BicyclesHo), linewidth = 2) +
  scale_color_manual(values = "magenta") +
  labs(title = "NEON Harvard Forest Field Site",
       subtitle = "Roads Where Bikes and Horses Are Allowed", 
       color = NULL) +
  coord_sf()
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Challenge 6: Plot Polygon by Attribute

Create a map of the state boundaries in the United States using the data
  located in your downloaded data folder: `NEON-DS-Site-Layout-Files/US-Boundary-Layers\US-State-Boundaries-Census-2014`.
Note that this dataset includes Z and M coordinates, which we do not need. 
Use the `st_zm()` function to drop these dimensions before plotting. 

When plotting, apply a line color to each state using its `region` value.
Be sure to add a legend to your plot as well.

:::::::::::::::  solution

## Solution

First we read in the data and check how many levels there are in the `region`
column:

```{r}
state_boundary_US <-
st_read("data/NEON-DS-Site-Layout-Files/US-Boundary-Layers/US-State-Boundaries-Census-2014.shp") %>%
# NOTE: We need neither Z nor M coordinates!
st_zm()

state_boundary_US$region <- as.factor(state_boundary_US$region)
levels(state_boundary_US$region)
```

Next we set a color vector with that many items:

```{r}
colors <- c("purple", "springgreen", "yellow", "brown", "navy")
```

Now we can create our plot:

```{r colored-state-boundaries, fig.cap="Map of the continental United States where the state lines are colored by region."}
ggplot() +
  geom_sf(data = state_boundary_US, 
          mapping = aes(color = region), size = 1) +
  scale_color_manual(values = colors) +
  labs(title = "Contiguous U.S. State Boundaries") +
  coord_sf()
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::



:::::::::::::::::::::::::::::::::::::::: keypoints

- Spatial objects in `sf` are similar to standard data frames and can be
  manipulated using the same functions.
- Almost any feature of a plot can be customized using the various functions
  and options in the `ggplot2` package.

::::::::::::::::::::::::::::::::::::::::::::::::::


